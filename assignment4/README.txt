Disclaimer : I had worked by myself on this assignment so I will not be talking about my partnerâ€™s contribution and such in this.

How it works: My assignment 4 has two aspects to it, encoding and decoding. My program is able to decode a text file into a Huffman tree and dumps it into a text file, where my decoder is able to decode it and write out the contents of the file. In order to this, I had to build the data structures required: Huffman trees, stacks, and priority queues. The stack is a simple last in first out stack that takes whatever item. For this particular assignment, it is a tree node. The priority queue is used in constructing the Huffman tree. It is essentially a line in which you remove the smallest items at all times. Thus, the priority queue must be sorted. The Huffman tree is the last data structure that we were required to build. The Huffman tree constructs the path ways in order to reconstruct the text file that we encoded. The encoder works by first opening the input file and constructing a histogram (array) based on the frequencies of the words. Next, we create the nodes that correspond to the frequency of the words in the histogram array. We then create a queue and insert each tree node into it. Next, we use the priority queue to construct the Huffman tree. We create an internal node for every two leaves that we have and combine them. By combing all these nodes, we have a Huffman tree. We next perform a post order traversal of the tree and build a corresponding code table for it. The code table is how we traverse the tree. If the character is more common, it will have a less complicated path to the node as we need to use it more often. After doing this, we write the specified magic number onto the file as it is a sign that we used our particular encoder to encode the file. We then write the length of the file, the size of the tree, and the contents of the tree. For the decoding aspect, we first read in the magic number so we know that it is a compressed file used by our encoder. We then read in the other information that we need to decode it such as the size of the uncompressed file and the tree size. We then reconstruct the tree that the encoded file wrote on the file by iterating through the saved tree array, an array in which we put the contents of the tree in. At this point we have reconstructed the contents of the file and are finished. The decompressed file should have the exact same contents as the original text file.

Notes: My program runs a little slower for very large files such as when I tried to encode Tom_Sawyer.txt. It will take around 5 to 10 seconds for it to completely encode it. Decode has no problems with speed whatsoever.